<h3 class="section-header">Controllers</h3>
<div class="section-content">
  <p>
    This documentation assumes that you are already familiar with
    <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a> architecture. In Dinoloop, controller is just a class. However, we need to add
    <span class="highlight-it">@Controller</span> decorator and must be derived from
    <span class="highlight-it">ApiController</span> class. Here is how you create a controller
  </p>
  <div class="code-snippet-terminal">
    <pre [innerHTML]="homeController"></pre>
  </div>
  <p>
    <span class="highlight-it">/home</span> is the prefix which allows all your routes share a common prefix.
    <a href="#">@Controller</a> decorator have more features.
  </p>
  <ul>
    <li>
      @Controller(null) or @Controller(undefined) raises
      <span class="highlight-it">InvalidRouteException</span>
    </li>
  </ul>
</div>
<h3 class="section-header">Action Methods</h3>
<div class="section-content">
  <p>
    Controller class contains methods and we can use variety of decorators (
    <a href="#">@HttpGet</a>,
    <a href="#">@HttpPost</a> ...) to make them as Action methods.
  </p>
  <div class="code-snippet-terminal">
    <pre [innerHTML]="actionMethod"></pre>
  </div>
  <p>
    <span class="highlight-it">@HttpGet</span> tells to create an endpoint. Here, we have created two endpoints
    <span class="highlight-it">/home/get</span> and
    <span class="highlight-it">/home/get/user/:id</span>. For the second endpoint, values are automatically parsed from named-segments and injected
    into parameters using
    <a href="#">ParameterInjection</a> technique. Values parsed from named-segments are always injected as string type. However, you
    can use data conversion techniques like
    <a href="#">@Parse</a>.
  </p>
  <ul>
    <li>
      @Http*(null) or @Http*(undefined) raises
      <span class="highlight-it">InvalidRouteException</span>. * indicates Get, Post, Patch etc.
    </li>
  </ul>
  <p>
    Now, when a GET request is made to any of these endpoints, Dinloop will return a json response with 200 status code. How
    is that possible? Generally, we distinguish two different approaches to send the response:
  </p>
  <p class="sub-section-content">1. Action method without @SendsResponse decorator</p>
  <p>
    In the example above, we haven't used
    <a href="#">@SendsResponse</a>. So, Dinoloop keeps waiting for result from controller, once the results are returned it invokes ResponseEndMiddleware
    (a built-in dinoware) which is responsible to send JSON response. Here is the pseudo code
  </p>
  <div class="code-snippet-terminal">
    <pre [innerHTML]="responseEndMiddleware"></pre>
  </div>
  <p>If result is undefined then it ends the response with 204 status code. Otherwise, it ends the response with 200 status
    code. You can override this behavior by creating you own dinoware using
    <a href="#">RequestEndMiddleware</a> technique. An example to implement
    <a href="#">content-negotation</a> using RequestEndMiddleware.
  </p>
  <ul>
    <li>
      When an action method is void or return value is undefined then it ends response with 204 status code.
    </li>
    <li>When action method returns
      <span class="highlight-it">null</span> or
      <span class="highlight-it">other</span> values, It ends responds with 200 status code and result is JSON parsed.
    </li>
  </ul>
  <p class="sub-section-content">2. Action method with @SendsResponse decorator</p>
  <div class="code-snippet-terminal">
    <pre [innerHTML]="sendsResponseUsed"></pre>
  </div>
  <p>
    In the example above, we have used
    <a href="#">@SendsResponse</a>. Dinoloop is now notified and it is the responsibility of this endpoint to send the response. Now,
    when a GET request is made to this endpoint, express method
    <a href="https://expressjs.com/en/api.html#res.download">res.download</a> ends the response.
  </p>
  <ul>
    <li>
      <a href="#">this.response</a> - derived from ApiController and it is of type
      <a href="https://expressjs.com/en/api.html#res">express.Response</a>
    </li>
    <li>
      It is better practise to have return type as
      <span class="highlight-it">void</span> when an action method has @SendsResponse since the return value is ignored.
    </li>
  </ul>
  <p>However, there are cases where you still want to process and continue your results with the
    <a href="#">chain of dinowares</a> (ex: after returning from callbacks). Here is one such example</p>
  <div class="code-snippet-terminal">
    <pre [innerHTML]="callbackEx"></pre>
  </div>
  <p>
    In the above example, we have got results after async-callback operation. Now we can end the response with
    <span class="highlight-it">this.response</span>, but we would like to continue these results with the chain of middlewares i.e. ResponseEndMiddleware.
    We can simply do that by using
    <a href="#">this.dino.proceed</a>, the response will end with 200 status code and JSON parsed result.
  </p>
  <ul>
    <li>
      <span class="highlight-it">this.dino.proceed</span> is derived from ApiController which proceeds the results to the next chain of middlewares.
    </li>
    <li>
      The 90% of javascript libraries uses
      <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">Callback</a> /
      <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> pattern which are still reusable using
      <span class="highlight-it">this.dino.proceed</span>
    </li>
    <li> We also have a
      <a href="#">Deferrer</a> built into dinoloop to convert promise objects to async-await pattern (if you are a lover of async-await).</li>
  </ul>
  <div class="remember-points">
    <p>
      <i class="fa fa-bullhorn" aria-hidden="true"></i>
      <span class="title">Remember</span>
    </p>
    <ul>
      <li>
        It is better practise to have every controller class name end with a word "Controller".
      </li>
      <li>
        It is better practise to have every controller class located in controllers folder of MVC application.
      </li>
    </ul>
  </div>
</div>
